priority -50

global !p

texMathZones = ['texMathZone'+x for x in
    ['A', 'AS', 'B', 'BS', 'C', 'CS', 'D', 'DS', 'E', 'ES', 'F', 'FS', 'G', 'GS', 'H', 'HS', 'I', 'IS', 'J', 'JS', 'K', 'KS', 'L', 'LS', 'DS', 'V', 'W', 'X', 'Y', 'Z']]

texIgnoreMathZones = ['texMathText']

texMathZoneIds = vim.eval('map('+str(texMathZones)+", 'hlID(v:val)')")
texIgnoreMathZoneIds = vim.eval('map('+str(texIgnoreMathZones)+", 'hlID(v:val)')")

ignore = texIgnoreMathZoneIds[0]

import re
def math():
    synstackids = vim.eval("synstack(line('.'), col('.') - (col('.')>=2 ? 1 : 0))")
    currentlinenumber = int(vim.eval("line('.')"))
    currentcolnumber = int(vim.eval("col('.')"))
    if (vim.eval('&filetype') in {'vimwiki', 'markdown', 'vimwiki.markdown', 'vimwiki.markdown.pandoc', 'markdown.vimwiki'}) \
		and '$' in vim.eval("getline(%d)"%currentlinenumber)[:currentcolnumber] \
		and "$" in vim.eval("getline(%d)"%currentlinenumber)[currentcolnumber-1:]:

        return True
    try:
        first = next(i for i in reversed(synstackids) if i in texIgnoreMathZoneIds or i in texMathZoneIds)
        return first != ignore
    except StopIteration:
        return False
endglobal
##############
# MATH STUFF #
##############
snippet eq "Equation" b
\begin{equation}
    $0
\end{equation}
endsnippet

snippet vec "vector" w
\\overrightarrow{${1}} ${0}
endsnippet

snippet eqnn "Equation without number" b
\begin{equation*}
    $0
\end{equation*}
endsnippet

snippet eqa "Equation array" b
\begin{eqnarray}
    $1 & $2 & $0
\end{eqnarray}
endsnippet

snippet eqann "Equation array without numbers" b
\begin{eqnarray*}
    $1 & $2 & $0
\end{eqnarray*}
endsnippet

snippet bmat "bmat" w
\begin{bmatrix} $1 \end{bmatrix} $0
endsnippet


context "math()"
snippet frac. "Fraction" wA
\frac{${1:${VISUAL:nom}}}{${2:denom}}
endsnippet

snippet frac "Fraction" w
\frac{${1:${VISUAL:nom}}}{${2:denom}}
endsnippet

snippet mat "Smart Matrix"
\begin{${1:p/b/v/V/B/small}matrix}
    $0
\end{$1matrix}
endsnippet


context "math()"
snippet '([A-Za-z])(\d)' "auto subscript" wrA
`!p snip.rv = match.group(1)`_`!p snip.rv = match.group(2)`
endsnippet

context "math()"
snippet '([A-Za-z])_(\d\d)' "auto subscript2" wrA
`!p snip.rv = match.group(1)`_{`!p snip.rv = match.group(2)`}
endsnippet

snippet lr( "left( right)" w
\left( ${1:${VISUAL}} \right)
endsnippet

snippet lr| "left| right|" w
\left| ${1:${VISUAL}} \right|
endsnippet

snippet lr{ "left\{ right\}" w
\left\\{ ${1:${VISUAL}} \right\\}
endsnippet

snippet lr[ "left[ right]" w
\left[ ${1:${VISUAL}} \right]
endsnippet

context "math()"
snippet ",([aAbBcCdDeEgGkKlLmMnNoOpPrRsStTxX])" "Greek alphabet" wrA
`!p
alphabet_map = {
    "a": "alpha",
    "A": "Alpha",
    "b": "beta",
    "B": "Beta",
    "c": "chi",
    "C": "Chi",
    "d": "delta",
    "D": "Delta",
    "e": "epsilon",
    "E": "Epsilon",
    "g": "gamma",
    "G": "Gamma",
    "k": "kappa",
    "K": "Kappa",
    "l": "lambda",
    "L": "Lambda",
    "m": "mu",
    "M": "Mu",
    "n": "nu",
    "N": "Nu",
    "o": "omega",
    "O": "Omega",
    "p": "phi",
    "P": "Phi",
    "r": "rho",
    "R": "Rho",
    "s": "sigma",
    "S": "Sigma",
    "t": "theta",
    "T": "Theta",
    "x": "xi",
    "X": "Xi",
}
snip.rv = "\\"+alphabet_map[match.group(1)]
`
endsnippet

snippet "([vco]?)dot(s?)\." "dot" wrA
`!p snip.rv = "\\"+match.group(1)+"dot"+match.group(2)`
endsnippet

snippet mi "math inline" w
$ ${1}$${0}
endsnippet

snippet mo "math another line" w
$$ ${1}$$${0}
endsnippet
